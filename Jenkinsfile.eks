pipeline {
    agent any
    
    environment {
        ECR_REGISTRY = '746491138596.dkr.ecr.us-east-1.amazonaws.com'
        ECR_REPOSITORY = 'fanda-fe/frontend'
        IMAGE_NAME = "${ECR_REGISTRY}/${ECR_REPOSITORY}"
        IMAGE_TAG = "${env.GIT_COMMIT.take(8)}"
        AWS_DEFAULT_REGION = 'us-east-1'
        DOCKER_BUILDKIT = '1'
    }
    
    options {
        buildDiscarder(logRotator(numToKeepStr: '10', daysToKeepStr: '30'))
        disableConcurrentBuilds()
        timeout(time: 20, unit: 'MINUTES')
    }
    
    stages {
        stage('트리거 검증') {
            steps {
                script {
                    def author = sh(script: "git log -1 --pretty=%an", returnStdout: true).trim()
                    def commitMessage = sh(script: "git log -1 --pretty=%B", returnStdout: true).trim()
                    
                    if (author == "Jenkins CI" || commitMessage.contains('[skip ci]')) {
                        echo "Jenkins CI 커밋 감지 - 파이프라인 스킵"
                        env.SKIP_ALL = 'true'
                        currentBuild.result = 'SUCCESS'
                        return
                    }
                    env.SKIP_ALL = 'false'
                }
            }
        }
        
        stage('환경 검증') {
            when { environment name: 'SKIP_ALL', value: 'false' }
            steps {
                echo "프론트엔드 AWS 빌드 시작: ${IMAGE_NAME}:${IMAGE_TAG}"
                sh '''
                    for file in package.json Dockerfile nginx/default.conf; do
                        [ ! -f "$file" ] && echo "$file 없음" && exit 1
                    done
                    echo "환경 검증 완료"
                '''
            }
        }
        
        stage('이미지 중복 확인') {
            when { environment name: 'SKIP_ALL', value: 'false' }
            steps {
                withCredentials([
                    string(credentialsId: 'aws-access-key-id', variable: 'AWS_ACCESS_KEY_ID'),
                    string(credentialsId: 'aws-secret-access-key', variable: 'AWS_SECRET_ACCESS_KEY'),
                    string(credentialsId: 'aws-session-token', variable: 'AWS_SESSION_TOKEN')
                ]) {
                    script {
                        def imageExists = sh(
                            script: '''
                                export AWS_ACCESS_KEY_ID="${AWS_ACCESS_KEY_ID}"
                                export AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY}"
                                export AWS_SESSION_TOKEN="${AWS_SESSION_TOKEN}"
                                aws ecr describe-images --repository-name ${ECR_REPOSITORY} --image-ids imageTag=${IMAGE_TAG} --region us-east-1 >/dev/null 2>&1
                            ''',
                            returnStatus: true
                        )
                        
                        env.SKIP_BUILD = imageExists == 0 ? 'true' : 'false'
                        echo env.SKIP_BUILD == 'true' ? 
                            "이미지 재사용: ${IMAGE_NAME}:${IMAGE_TAG}" : 
                            "새 이미지 빌드: ${IMAGE_NAME}:${IMAGE_TAG}"
                    }
                }
            }
        }
        
        stage('빌드 & 푸시') {
            when { 
                allOf {
                    environment name: 'SKIP_ALL', value: 'false'
                    environment name: 'SKIP_BUILD', value: 'false'
                }
            }
            steps {
                withCredentials([
                    string(credentialsId: 'aws-access-key-id', variable: 'AWS_ACCESS_KEY_ID'),
                    string(credentialsId: 'aws-secret-access-key', variable: 'AWS_SECRET_ACCESS_KEY'),
                    string(credentialsId: 'aws-session-token', variable: 'AWS_SESSION_TOKEN')
                ]) {
                    sh '''
                        # AWS 자격증명 설정
                        export AWS_ACCESS_KEY_ID="${AWS_ACCESS_KEY_ID}"
                        export AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY}"
                        export AWS_SESSION_TOKEN="${AWS_SESSION_TOKEN}"

                        # ECR 로그인
                        aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin ${ECR_REGISTRY}
                        
                        # Docker 이미지 빌드
                        docker build -t ${IMAGE_NAME}:${IMAGE_TAG} -t ${IMAGE_NAME}:latest \
                            --label "version=${IMAGE_TAG}" \
                            --label "build-date=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
                            --label "service=frontend" .
                        
                        # ECR에 이미지 푸시
                        docker push ${IMAGE_NAME}:${IMAGE_TAG}
                        docker push ${IMAGE_NAME}:latest
                        
                        echo "프론트엔드 빌드 완료: ${IMAGE_NAME}:${IMAGE_TAG}"
                    '''
                }
            }
        }
        
        stage('보안 스캔') {
            when { 
                allOf {
                    environment name: 'SKIP_ALL', value: 'false'
                    environment name: 'SKIP_BUILD', value: 'false'
                }
            }
            steps {
                sh '''
                    echo "Trivy 보안 스캔 실행..."
                    trivy image --server http://192.168.2.100:30367 \
                       --exit-code 1 --severity CRITICAL ${IMAGE_NAME}:${IMAGE_TAG} || echo "보안 스캔 경고 - 계속 진행"
                '''
            }
        }

        stage('배포 업데이트') {
            when { environment name: 'SKIP_ALL', value: 'false' }
            steps {
                script {
                    try {
                        withCredentials([usernamePassword(
                            credentialsId: 'github-credentials',
                            usernameVariable: 'GITHUB_USER',
                            passwordVariable: 'GITHUB_TOKEN'
                        )]) {
                            sh '''
                                git config --global user.email "jenkins@company.com"
                                git config --global user.name "Jenkins CI"
                                
                                # GitHub 인증된 URL로 fetch
                                git remote set-url origin https://${GITHUB_TOKEN}@github.com/T1F4-aws-cloud-school/fanda-frontend.git
                                git fetch origin
                                git checkout main
                                git reset --hard origin/main
                            '''
                            
                            def currentTag = sh(
                                script: "grep -o 'image: .*/frontend:.*' k8s/eks/deployment.yaml | cut -d':' -f3 || echo 'none'",
                                returnStdout: true
                            ).trim()
                            
                            if (currentTag == env.IMAGE_TAG) {
                                echo "이미지 태그 동일 - 스킵"
                                return
                            }
                            
                            sh '''
                                # deployment.yaml 이미지 태그 업데이트
                                sed -i "s|image: ${ECR_REGISTRY}/${ECR_REPOSITORY}:.*|image: ${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}|g" k8s/eks/deployment.yaml
                                
                                git add k8s/eks/deployment.yaml
                                git commit -m "Auto-update frontend image tag to ${IMAGE_TAG} [skip ci]"
                                git push origin main
                                echo "Git 푸시 성공"
                            '''
                        }
                        
                        echo "배포 업데이트 완료 - ArgoCD가 배포를 진행합니다"
                        
                    } catch (Exception e) {
                        echo "배포 업데이트 실패: ${e.message}"
                        currentBuild.result = 'UNSTABLE'
                    }
                }
            }
        }
    }
    
    post {
        always {
            script {
                if (env.SKIP_ALL != 'true') {
                    withCredentials([
                        string(credentialsId: 'aws-access-key-id', variable: 'AWS_ACCESS_KEY_ID'),
                        string(credentialsId: 'aws-secret-access-key', variable: 'AWS_SECRET_ACCESS_KEY'),
                        string(credentialsId: 'aws-session-token', variable: 'AWS_SESSION_TOKEN')
                    ]) {
                        sh '''
                            export AWS_ACCESS_KEY_ID="${AWS_ACCESS_KEY_ID}"
                            export AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY}"
                            export AWS_SESSION_TOKEN="${AWS_SESSION_TOKEN}"
                            
                            docker logout ${ECR_REGISTRY} 2>/dev/null || true
                            docker rmi ${IMAGE_NAME}:${IMAGE_TAG} ${IMAGE_NAME}:latest 2>/dev/null || true
                            docker system prune -f --volumes
                        '''
                    }
                }
            }
        }
        success {
            echo env.SKIP_ALL == 'true' ? "자동 스킵 완료" : 
                 env.SKIP_BUILD == 'true' ? "이미지 재사용 성공!" : "완전 자동화 성공!"
        }
        unstable { echo "빌드 성공, Git 업데이트 실패" }
        failure { echo "빌드 실패!" }
        cleanup { sh 'docker container prune -f || true' }
    }
}